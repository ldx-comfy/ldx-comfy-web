---
// src/components/DynamicWorkflow.astro
import ImageUploader from './ImageUploader.astro';
import ImageEditor from './ImageEditor.astro';
import PromptInput from './PromptInput.astro';
import ToggleWithText from './ToggleWithText.astro';
import { getTranslator } from '@gudupao/astro-i18n';
import { API_URL_TWO } from '../config/env.ts';

interface WorkflowParam {
  node_id: string;
  title: string;
  class_type: string;
  value?: any;
}

interface Props {
  params: WorkflowParam[];
  workflowId: string;
  executionResult?: any;
  executionError?: string | null;
  apiUrlTwo: string;
  initialValues?: Record<string, any>; // 新增：用于导入历史值的对象
  showExecuteButton?: boolean; // 新增：控制是否显示执行按钮
}

const { params = [], workflowId, executionResult, executionError, apiUrlTwo, initialValues = {}, showExecuteButton = true } = Astro.props;

// Get language from params or cookie
const lang = Astro.params.lang || Astro.cookies.get('lang')?.value || 'en';
const t = getTranslator(lang);

// Get API_URL_TWO from env
const apiUrlTwoValue = API_URL_TWO;
---

<!-- Image Editor Modal -->
<ImageEditor />

<div class="workflow-container">
  {
    params.map((param) => {
      const initialValue = initialValues[param.node_id] || param.value;
      return (
        <div class="component-wrapper" data-node-id={param.node_id} data-class-type={param.class_type} data-initial-value={JSON.stringify(initialValue)}>
          {(() => {
             if (param.class_type === 'LoadImageOutput') {
               return <ImageUploader title={param.title} initialImage={initialValue} />;
             } else if (param.class_type === 'Text') {
               return <PromptInput placeholder={param.title} initialValue={initialValue} />;
             } else if (param.class_type === 'CLIPTextEncode' || /CLIPTextEncode/.test(param.class_type)) {
               // Map CLIP text encode nodes to a text prompt input
               return <PromptInput placeholder={param.title} initialValue={initialValue} />;
             } else if (param.class_type === 'Switch any [Crystools]') {
               return <ToggleWithText text={param.title} initialState={Boolean(initialValue)} />;
             } else {
               return (
                 <div class="unknown-component">
                   <p>{t('dynamicworkflow.unknownComponent')}: {param.class_type}</p>
                   <p>{t('dynamicworkflow.nodeId')}: {param.node_id}</p>
                   <p>{t('dynamicworkflow.title')}: {param.title}</p>
                   {initialValue && <p>Initial Value: {JSON.stringify(initialValue)}</p>}
                 </div>
               );
             }
           })()}
        </div>
      );
    })
  }
  
  {showExecuteButton && (
    <div class="workflow-controls">
      <form method="post" action="" id="workflow-form" data-api-url={apiUrlTwoValue}>
        <input type="hidden" name="workflowId" value={workflowId} />
        <input type="hidden" name="params" value={JSON.stringify(params)} />
        <button
          class="execute-btn"
          type="submit"
        >
          {t('dynamicworkflow.execute')}
        </button>

      <script type="module">
        (() => {
          try {
            const form = document.getElementById('workflow-form');
            if (!form) return;

            // Get API URL from data attribute
            const apiUrlTwo = form.getAttribute('data-api-url');

            // Initialize form fields with initial values
            const initializeFormFields = () => {
              const wrappers = form.querySelectorAll('.component-wrapper');
              wrappers.forEach((wrapEl) => {
                const nodeId = wrapEl.getAttribute('data-node-id');
                const classType = wrapEl.getAttribute('data-class-type');
                const initialValueStr = wrapEl.getAttribute('data-initial-value');

                if (!nodeId || !initialValueStr) return;

                let initialValue;
                try {
                  initialValue = JSON.parse(initialValueStr);
                } catch (e) {
                  initialValue = initialValueStr;
                }

                if (classType === 'Text' || classType.includes('CLIPTextEncode')) {
                  const ta = wrapEl.querySelector('textarea');
                  if (ta && initialValue && !ta.value) {
                    ta.value = String(initialValue);
                  }
                } else if (classType === 'Switch any [Crystools]') {
                  const cb = wrapEl.querySelector('input[type="checkbox"]');
                  if (cb && initialValue !== undefined) {
                    cb.checked = Boolean(initialValue);
                  }
                } else if (classType === 'LoadImageOutput') {
                  const img = wrapEl.querySelector('img.image-preview');
                  if (img && initialValue && !img.src) {
                    // Ensure the base64 data is properly handled
                    try {
                      img.src = initialValue;
                      img.hidden = false;
                      const editBtn = wrapEl.querySelector('.edit-btn');
                      if (editBtn) editBtn.hidden = false;
                      const uploadBox = wrapEl.closest('.upload-box');
                      if (uploadBox) uploadBox.classList.add('preview-shown');
                    } catch (e) {
                      console.error('[DynamicWorkflow] Error setting image src:', e);
                    }
                  }
                }
              });
            };

            // Initialize fields on load
            initializeFormFields();

            async function serializeParamsToHiddenInput() {
              try {
                const container = form.closest('.workflow-container') || document;
                const wrappers = container.querySelectorAll('.component-wrapper');
                const paramsInput = form.querySelector('input[name="params"]');
                if (!paramsInput) return;

                let params = [];
                try { params = JSON.parse(paramsInput.value) || []; } catch {}
                const paramsById = new Map((Array.isArray(params) ? params : []).map((p) => [String(p.node_id), p]));

                wrappers.forEach((wrapEl) => {
                  const nodeId = wrapEl.getAttribute('data-node-id');
                  const classType = (wrapEl.getAttribute('data-class-type') || '');
                  if (!nodeId) return;

                  let valueProvided = null;

                  if (classType === 'Text' || classType.includes('CLIPTextEncode')) {
                    const ta = wrapEl.querySelector('textarea');
                    if (ta) valueProvided = ta.value;
                  } else if (classType === 'Switch any [Crystools]') {
                    const cb = wrapEl.querySelector('input[type="checkbox"]');
                    if (cb) valueProvided = cb.checked;
                  } else if (classType === 'LoadImageOutput') {
                    const fi = wrapEl.querySelector('input[type="file"]');
                    if (fi && fi.files && fi.files.length > 0) {
                      valueProvided = fi.files[0].name;
                    } else {
                      // Check if there's an initial image
                      const img = wrapEl.querySelector('img.image-preview');
                      if (img && img.src && !img.hidden) {
                        valueProvided = img.src;
                      }
                    }
                  }

                  if (valueProvided !== null) {
                    const base = paramsById.get(String(nodeId)) || { node_id: String(nodeId), title: '', class_type: classType };
                    base.value = valueProvided;
                    paramsById.set(String(nodeId), base);
                  }
                });

                paramsInput.value = JSON.stringify(Array.from(paramsById.values()));
              } catch (err) {
                console.error('[DynamicWorkflow] serialize params failed:', err);
              }
            }

            function renderLoading(root) {
              if (!root) return;
              root.innerHTML = `
                <div class="execution-result">
                  <h3>Loading...</h3>
                  <div class="loading-spinner"></div>
                </div>
              `;
            }

            function escapeHtml(str) {
              return String(str)
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;')
                .replaceAll('"', '&quot;')
                .replaceAll("'", '&#39;');
            }

            function renderResult(root, images, result, error) {
              if (!root) return;
              if (error) {
                const errStr = String(error);
                const isMultiline = /\n/.test(errStr);
                root.innerHTML = isMultiline
                  ? '<div class="execution-error"><h3>Error:</h3><pre>' + escapeHtml(errStr) + '</pre></div>'
                  : '<div class="execution-error"><h3>Error:</h3><p>' + escapeHtml(errStr) + '</p></div>';
                return;
              }
              if (images && images.length) {
                const html = images.map((img) => {
                  let url;
                  const imgStr = String(img);
                  if (imgStr.startsWith('data:')) {
                    // Base64 data URL
                    url = imgStr;
                  } else if (imgStr.startsWith('http')) {
                    // HTTP URL
                    url = imgStr;
                  } else {
                    // File path - construct full URL
                    url = `${apiUrlTwo}/${imgStr.replace(/^\/+/, '')}`;
                  }
                  return `
                    <a href="${url}" target="_blank" rel="noopener noreferrer">
                      <img src="${url}" alt="Result image"
                        loading="lazy"
                        style="max-width: 100%; height: auto; border-radius: 8px; border: 1px solid var(--border-color); margin-bottom: 1rem;" />
                    </a>
                  `;
                }).join('');
                root.innerHTML = `
                  <div class="execution-result">
                    <h3>Result:</h3>
                    <div>${html}</div>
                  </div>
                `;
                return;
              }
              if (result) {
                root.innerHTML = `
                  <div class="execution-result">
                    <h3>Result:</h3>
                    <pre>${escapeHtml(JSON.stringify(result, null, 2))}</pre>
                  </div>
                `;
                return;
              }
              root.innerHTML = `
                <div class="no-results">
                  <div class="no-results-icon">📊</div>
                  <h3>Results will appear here</h3>
                  <p>Execute to see results</p>
                </div>
              `;
            }

            form.addEventListener('submit', async (e) => {
              e.preventDefault();
              const submitBtn = form.querySelector('button[type="submit"]');
              if (submitBtn) submitBtn.disabled = true;

              await serializeParamsToHiddenInput();

              const workflowIdInput = form.querySelector('input[name="workflowId"]');
              const paramsInput = form.querySelector('input[name="params"]');
              const workflowId = workflowIdInput ? String(workflowIdInput.value) : '';
              const paramsJson = paramsInput ? String(paramsInput.value) : '[]';

              const results = document.querySelector('.results-container');
              renderLoading(results);

              let reqUrl = '';

              try {
                const fd = new FormData();
                fd.append('nodes', paramsJson);

                // 附加圖片文件（來自 LoadImageOutput）
                try {
                  const container = form.closest('.workflow-container') || document;
                  const wrappers = container.querySelectorAll('.component-wrapper');
                  wrappers.forEach((wrapEl) => {
                    const classType = String(wrapEl.getAttribute('data-class-type') || '');
                    if (classType === 'LoadImageOutput') {
                      const fi = wrapEl.querySelector('input[type="file"]');
                      if (fi && fi.files && fi.files.length > 0) {
                        const file = fi.files[0];
                        console.log(`Attaching file: name=${file.name}, size=${file.size}, type=${file.type}`);
                        fd.append('files', file, file.name);
                      }
                    }
                  });
                } catch (e) {
                  console.warn('[DynamicWorkflow] attach files failed:', e);
                }

                // Get token from cookie
                function getTokenFromCookie() {
                  const cookies = document.cookie.split(';');
                  for (let cookie of cookies) {
                    const [name, value] = cookie.trim().split('=');
                    if (name === 'auth_token' || name === 'auth_token_js') {
                      return value;
                    }
                  }
                  return null;
                }
                
                const token = getTokenFromCookie();
                const headers = {};
                if (token) {
                  headers['Authorization'] = `Bearer ${token}`;
                }
                
                reqUrl = `${apiUrlTwo}/api/v1/forms/workflows/${encodeURIComponent(workflowId)}/execute`;
                const resp = await fetch(reqUrl, {
                  method: 'POST',
                  body: fd,
                  headers: headers
                });

                if (!resp.ok) {
                  let bodyText = '';
                  try { bodyText = await resp.text(); } catch {}
                  let headers = '';
                  try {
                    headers = Array.from(resp.headers.entries()).map(([k,v]) => k + ': ' + v).join('\n');
                  } catch {}
                  const message = [
                    `HTTP ${resp.status} ${resp.statusText}`,
                    `URL: ${reqUrl || '(unknown)'}`,
                    headers ? `Headers:\n${headers}` : 'Headers: (unavailable)',
                    `Body:\n${String(bodyText).slice(0, 2000)}`
                  ].join('\n');
                  throw new Error(message);
                }

                const data = await resp.json();
                const images = (data && (data.images || (data.result && data.result.images))) || null;
                const result = data && (data.result || data);

                renderResult(results, images, result, null);
              } catch (err) {
                try { console.error('[DynamicWorkflow] fetch failed:', err); } catch {}
                let detail = `[NetworkError] ${err && err.name ? err.name : 'Error'}: ${err && err.message ? err.message : String(err)}\n`;
                try {
                  detail += `URL: ${reqUrl || '(unknown)'}\n`;
                  detail += `Online: ${typeof navigator !== 'undefined' ? navigator.onLine : 'n/a'}\n`;
                  detail += `Time: ${new Date().toISOString()}\n`;
                  detail += `User-Agent: ${typeof navigator !== 'undefined' ? navigator.userAgent : 'n/a'}\n`;
                  if (err && err.stack) {
                    detail += `Stack: ${String(err.stack).split('\n').slice(0, 8).join('\n')}\n`;
                  }
                } catch {}
                renderResult(results, null, null, detail);
              } finally {
                if (submitBtn) submitBtn.disabled = false;
              }
            });
          } catch (e) {
            console.error('[DynamicWorkflow] init failed:', e);
          }
        })();
      </script>
    </form>
  </div>
  )}

  {executionResult && (
    <div class="execution-result">
      <h3>{t('dynamicworkflow.result')}:</h3>
      <pre>{JSON.stringify(executionResult, null, 2)}</pre>
    </div>
  )}
  
  {executionError && (
    <div class="execution-error">
      <h3>{t('dynamicworkflow.error')}:</h3>
      <p>{executionError}</p>
    </div>
  )}
</div>

<style>
  .workflow-container {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    padding: 1.5rem;
    width: 100%;
    max-width: 600px;
    margin: 0 auto;
  }

  .component-wrapper {
    display: flex;
    justify-content: center;
  }

  .workflow-controls {
    display: flex;
    justify-content: center;
  }

  .unknown-component {
    padding: 1.5rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 0.75rem;
    color: var(--text-primary);
  }

  .execute-btn {
    padding: 14px 28px;
    background: var(--accent-color);
    color: white;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    min-height: 48px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    position: relative;
    overflow: hidden;
  }

  .execute-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
  }

  .execute-btn:hover {
    background: var(--accent-hover);
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
  }

  .execute-btn:hover::before {
    left: 100%;
  }

  .execute-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
  }

  .execute-btn:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
  }

  .execute-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }

  /* Mobile responsive */
  @media (max-width: 768px) {
    .execute-btn {
      padding: 16px 24px;
      font-size: 16px;
      min-height: 52px;
      width: 100%;
      max-width: 300px;
    }
  }

  @media (max-width: 480px) {
    .execute-btn {
      padding: 18px 20px;
      font-size: 16px;
      min-height: 56px;
    }
  }
</style>